Case 1: Without new keyword
String A = "Catherine";
String B = "Catherine";


ðŸ‘‰ Here, both A and B will point to the same object in something called the String Pool (a special memory area in Java where strings are stored).

Because "Catherine" is already created once in the pool, Java reuses it for efficiency.

So A == B â†’ true (they point to the same object).

ðŸ”¹ Case 2: With new keyword
String S1 = new String("Catherine");
String S2 = new String("Catherine");


ðŸ‘‰ Here, even though the content ("Catherine") is the same, Java will create a new object every time you use new.

So S1 and S2 are two different objects in memory.

Thatâ€™s why S1 == S2 â†’ false.

But S1.equals(S2) â†’ true (because .equals() checks content, not memory location).






âœ… Summary in one line:

"Catherine" â†’ stored in the String Pool, reused, same object.

new String("Catherine") â†’ always creates a new object in heap memory, even if the content is same.


